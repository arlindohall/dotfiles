#!/usr/bin/env ruby

class Args
  def self.end_branch
    raise "Must provide branch" unless ARGV[0]
    ARGV[0]
  end

  def self.start_branch = ARGV[1] || "main"
end

class Command
  COMMAND_TO_GET_CHANGED_FILES =
    "ls (git diff #{Args.start_branch} #{Args.end_branch} --name-only --relative) 2>/dev/null"

  class TestCommand
    def name = :test
    def fix_command
      "dev test (#{COMMAND_TO_GET_CHANGED_FILES}) --watch"
    end
  end

  class LintCommand
    def name = :lint
    def fix_command
      "pnpm eslint (#{COMMAND_TO_GET_CHANGED_FILES}) --quiet --fix"
    end
  end

  class TypeCheckCommand
    def name = :type_check
    def fix_command
      "dev type-check"
    end
  end

  attr_reader :command_type
  def initialize(command_type)
    @command_type = command_type
  end

  def run_message(current_branch, command)
    <<~COMMAND_MESSAGE
      Running command from branch
      ----------
      #{current_branch}
      ----------

      Running command
      ----------
      #{command}
      ----------
    COMMAND_MESSAGE
  end

  def error_message
    <<~CLOSE_MESSAGE

      Exiting due to failure...

      Failed trying to run
      ----------
      #{command}
      ----------

      Failed running on branch
      ----------
      #{current_branch}
      ----------

      Started from branch
      ----------
      #{Args.end_branch}
      ----------

      To go back to the begining, please run:
      git switch #{Args.end_branch}

      To run this program again from the failed branch, please run:
      ----------
      #{$0} #{Args.end_branch} #{current_branch}
      ----------

      This is a #{command_type.name} error, try running the following to debug/ fix it:
      ----------
      #{command_type.fix_command}
      ----------
    CLOSE_MESSAGE
  end
end

class Runner
  attr_reader :command, :git_changed, :command_type
  def initialize(command:, git_changed:, command_type:)
    @command = command
    @git_changed = git_changed
    @command_type = command_type
  end

  def run
    current_branch = `git branch --show-current`.strip

    puts command_type.run_message(current_branch, command)

    system command.gsub("CHANGESET", git_changed.join(" "))
    return if $?.exitstatus == 0

    puts command_type.error_message
    abort
  end
end

class Main
  def self.memoize(method_name)
    method = instance_method(method_name)
    define_method(method_name) do |*args|
      @memo ||= {}
      @memo[method_name] ||= {}
      @memo[method_name][args] ||= method.bind(self).call(*args)
    end
  end

  def self.call = new.call

  def call
    branch(Args.end_branch)

    for branch in branches
      puts "branch: #{branch}"
      system "git switch #{branch}"
      git_changed = `ls #{git_all} 2>/dev/null`.split
      changed_tests = git_changed.filter { |fn| fn.include?("test") }

      try_to_run "/opt/dev/bin/dev test CHANGESET",
                 changed_tests,
                 Command::TestCommand
      try_to_run "ADMIN_SETUP=unified /opt/dev/bin/dev test CHANGESET",
                 changed_tests,
                 Command::TestCommand
      try_to_run "/opt/dev/bin/dev type-check",
                 git_changed,
                 Command::TypeCheckCommand
      try_to_run "pnpm eslint CHANGESET --quiet",
                 git_changed,
                 Command::LintCommand
    end
  end

  def branch(name)
    system "git switch #{Args.end_branch}"
    abort unless $?.exitstatus == 0
  end

  def try_to_run(command, git_changed, command_type)
    return unless git_changed.any?

    Runner.new(
      command: command,
      git_changed: git_changed,
      command_type: Command.new(command_type)
    ).run
  end

  memoize def branches
    `git ll #{Args.start_branch}^..`.scan(
      %r{\((miller[-/\w]+)\)|HEAD -> (miller[-/\w]+)}
    )
      .flatten
      .compact
      .reverse
  end

  memoize def git_all
    branch_expression =
      Args.start_branch == "main" ? "main" : "#{Args.start_branch}^"
    files =
      `git diff #{branch_expression}..#{Args.end_branch} --name-only --relative`

    files.split.join(" ")
  end
end

Main.call
