#!/usr/bin/env ruby
# frozen_string_literal: true
# typed: true

require 'English'
class Args
  def self.end_branch
    raise 'Must provide branch' unless ARGV[0]

    ARGV[0]
  end

  def self.start_branch = ARGV[1] || 'main'
end

class Command
  COMMAND_TO_GET_CHANGED_FILES =
    "ls (git diff #{Args.start_branch} #{Args.end_branch} --name-only --relative) 2>/dev/null".freeze
  COMMAND_TO_GET_CHANGED_SO_FAR_FILES =
    "ls (git diff #{Args.start_branch}..#{`git branch --show-current`.strip} --name-only --relative) 2>/dev/null".freeze

  class TestCommand
    def name = :test

    def fix_command
      "dev test (#{COMMAND_TO_GET_CHANGED_FILES}) --watch"
    end
  end

  class LintCommand
    def name = :lint

    def fix_command
      "pnpm eslint (#{COMMAND_TO_GET_CHANGED_SO_FAR_FILES}) --quiet --fix"
    end
  end

  class TypeCheckCommand
    def name = :type_check

    def fix_command
      'dev type-check'
    end
  end

  attr_reader :command, :command_type, :changeset

  def initialize(command, command_type, changeset)
    @command = command
    @command_type = command_type
    @changeset = changeset
  end

  def current_branch
    `git branch --show-current`.strip
  end

  def execute
    system command.gsub('CHANGESET', changeset.join(' '))
  end

  def run_message
    <<~COMMAND_MESSAGE
      Running command from branch
      ----------
      #{current_branch}
      ----------

      Running command
      ----------
      #{command}
      ----------

      Including changeset
      ----------
      #{changeset.join(' ')}
      ----------
    COMMAND_MESSAGE
  end

  def error_message
    <<~CLOSE_MESSAGE

      Exiting due to failure...

      Failed trying to run
      ----------
      #{command}
      ----------

      Failed running on branch
      ----------
      #{current_branch}
      ----------

      Started from branch
      ----------
      #{Args.end_branch}
      ----------

      To go back to the begining, please run:
      git switch #{Args.end_branch}

      To run this program again from the failed branch, please run:
      ----------
      #{$PROGRAM_NAME} #{Args.end_branch} #{current_branch}
      ----------

      This is a #{command_type.name} error, try running the following to debug/ fix it:
      ----------
      #{command_type.fix_command}
      ----------
    CLOSE_MESSAGE
  end
end

class Runner
  attr_reader :command

  def initialize(command:)
    @command = command
  end

  def run
    puts command.run_message

    command.execute
    return if $CHILD_STATUS.exitstatus.zero?

    puts command.error_message
    abort
  end
end

class Main
  def self.memoize(method_name)
    method = instance_method(method_name)
    define_method(method_name) do |*args|
      @memo ||= {}
      @memo[method_name] ||= {}
      @memo[method_name][args] ||= method.bind(self).call(*args)
    end
  end

  def self.call = new.call

  def call
    branches.each do |target|
      branch(target)

      try_to_run 'pnpm eslint CHANGESET --quiet',
                 git_changed_so_far,
                 Command::LintCommand
      try_to_run '/opt/dev/bin/dev test CHANGESET',
                 changed_tests,
                 Command::TestCommand
      try_to_run 'ADMIN_SETUP=unified /opt/dev/bin/dev test CHANGESET',
                 changed_tests,
                 Command::TestCommand
      try_to_run '/opt/dev/bin/dev type-check',
                 git_changed,
                 Command::TypeCheckCommand
    end
  end

  def branch(name)
    puts "branch: #{name}"
    system "git switch #{name}"
    abort unless $CHILD_STATUS.exitstatus.zero?
  end

  def try_to_run(command, changeset, command_type)
    return unless changeset.any?

    Runner.new(command: Command.new(command, command_type.new, changeset)).run
  end

  memoize def branches
    `git ll #{Args.start_branch}^..#{Args.end_branch}`.scan(
      %r{\((miller[-/\w]+)\)|HEAD -> (miller[-/\w]+)}
    )
                                                      .flatten
                                                      .compact
                                                      .reverse
  end

  def git_changed_so_far
    filter_exists(`git branch --show-current`.strip)
  end

  def git_changed
    filter_exists(Args.end_branch)
  end

  def filter_exists(files)
    `ls #{git_all(files).join(' ')} 2>/dev/null`.split
  end

  def git_all(to_branch)
    `git diff #{branch_expression}..#{to_branch} --name-only --relative`.split
  end

  def changed_tests
    git_changed.filter { |fn| fn.include?('test') }
  end

  def branch_expression
    Args.start_branch == 'main' ? 'main' : "#{Args.start_branch}^"
  end
end

Main.call
