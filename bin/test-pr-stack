#!/usr/bin/env ruby
# frozen_string_literal: true
# typed: true

require 'English'
class Args
  def self.end_branch
    raise 'Must provide branch' unless instance.end_branch

    instance.end_branch
  end

  def self.start_branch = instance.start_branch
  def self.run_step = instance.run_step

  def self.instance
    @instance ||= new(ARGV).tap(&:parse!)
  end

  attr_reader :argv, :start_branch, :end_branch, :run_step

  def initialize(argv)
    @argv = argv
  end

  def parse! # rubocop:disable Metrics/MethodLength
    args = @argv.to_a.dup
    until args.empty?
      case (arg = args.shift)
      when '--start'
        @start_branch = args.shift
      when '--end'
        @end_branch = args.shift
      when '--run'
        @run_step = args.shift
      else
        puts "Unknown argument: #{arg} {full_args=#{@argv}}"
        puts "Usage: #{File.basename($PROGRAM_NAME)} --start <start_branch> [--end <end_branch> --run <run_step>]"
        abort
      end
    end
  end
end

class Command
  COMMAND_TO_GET_CHANGED_FILES =
    "ls (git diff #{Args.start_branch} #{Args.end_branch} --name-only --relative) 2>/dev/null".freeze
  COMMAND_TO_GET_CHANGED_SO_FAR_FILES =
    "ls (git diff #{Args.start_branch}..#{`git branch --show-current`.strip} --name-only --relative) 2>/dev/null".freeze

  class TestCommand
    def name = :test

    def initialize(env = nil)
      @env = env
    end

    def fix_command
      return "dev test (#{COMMAND_TO_GET_CHANGED_FILES}) --watch" unless @env

      "#{@env} dev test (#{COMMAND_TO_GET_CHANGED_FILES}) --watch"
    end
  end

  class LintCommand
    def name = :lint

    def fix_command
      "pnpm eslint (#{COMMAND_TO_GET_CHANGED_SO_FAR_FILES}) --quiet --fix"
    end
  end

  class TypeCheckCommand
    def name = :type_check

    def fix_command
      'dev type-check'
    end
  end

  attr_reader :command, :command_type, :changeset

  def initialize(command:, command_type:, changeset:)
    @command = command
    @command_type = command_type
    @changeset = changeset
  end

  def current_branch
    `git branch --show-current`.strip
  end

  def execute
    system command.gsub('CHANGESET', changeset.join(' '))
  end

  def run_message
    <<~COMMAND_MESSAGE
      Running command from branch
      ----------
      #{current_branch}
      ----------

      Running command
      ----------
      #{command}
      ----------

      Including changeset
      ----------
      #{changeset.join(' ')}
      ----------
    COMMAND_MESSAGE
  end

  def error_message
    <<~CLOSE_MESSAGE

      Exiting due to failure...

      Failed trying to run
      ----------
      #{command}
      ----------

      Failed running on branch
      ----------
      #{current_branch}
      ----------

      Started from branch
      ----------
      #{Args.end_branch}
      ----------

      To go back to the begining, please run:
      git switch #{Args.end_branch}

      To run this program again from the failed branch, please run:
      ----------
      #{$PROGRAM_NAME} #{Args.end_branch} #{current_branch}
      ----------

      This is a #{command_type.name} error, try running the following to debug/ fix it:
      ----------
      #{command_type.fix_command}
      ----------
    CLOSE_MESSAGE
  end
end

class Runner
  attr_reader :command, :changeset, :command_type

  def self.try(command:, changeset:, command_type:)
    new(command:, changeset:, command_type:).try
  end

  def initialize(command:, changeset:, command_type:)
    @command = command
    @changeset = changeset
    @command_type = command_type
  end

  def try
    return unless changeset.any?

    run(
      Command.new(
        command: command,
        command_type: command_type,
        changeset: changeset
      )
    )
  end

  def run(actual_command)
    puts actual_command.run_message

    actual_command.execute
    return if $CHILD_STATUS.exitstatus.zero?

    puts actual_command.error_message
    abort
  end
end

class Main
  LINT = 'pnpm eslint CHANGESET --quiet'
  TEST = '/opt/dev/bin/dev test CHANGESET'
  TEST_UNIFIED = 'ADMIN_SETUP=unified /opt/dev/bin/dev test CHANGESET'
  TYPE_CHECK = '/opt/dev/bin/dev type-check'

  def self.memoize(method_name)
    method = instance_method(method_name)
    define_method(method_name) do |*args|
      @memo ||= {}
      @memo[method_name] ||= {}
      @memo[method_name][args] ||= method.bind(self).call(*args)
    end
  end

  def self.call = new.call

  def call # rubocop:disable Metrics/MethodLength
    branches.each do |target|
      branch(target)

      try_to_run LINT,
                 git_changed_so_far,
                 Command::LintCommand.new
      try_to_run TEST,
                 changed_tests,
                 Command::TestCommand.new
      try_to_run TEST_UNIFIED,
                 changed_tests,
                 Command::TestCommand.new('ADMIN_SETUP=unified')
      try_to_run TYPE_CHECK,
                 git_changed,
                 Command::TypeCheckCommand.new
    end
  end

  def branch(name)
    puts "branch: #{name}"
    system "git switch #{name}"
    abort unless $CHILD_STATUS.exitstatus.zero?
  end

  def try_to_run(command, changeset, command_type)
    Runner.try(command: command, changeset: changeset, command_type: command_type)
  end

  memoize def branches
    `git ll #{Args.start_branch}^..#{Args.end_branch}`
      .scan(%r{\((miller[-/\w]+)\)|HEAD -> (miller[-/\w]+)})
      .flatten
      .compact
      .reverse
  end

  def git_changed_so_far
    filter_exists(`git branch --show-current`.strip)
  end

  def git_changed
    filter_exists(Args.end_branch)
  end

  def filter_exists(files)
    `ls #{git_all(files).join(' ')} 2>/dev/null`.split
  end

  def git_all(to_branch)
    `git diff #{branch_expression}..#{to_branch} --name-only --relative`.split
  end

  def changed_tests
    git_changed.filter { |fn| fn.include?('test') }
  end

  def branch_expression
    Args.start_branch == 'main' ? 'main' : "#{Args.start_branch}^"
  end
end

case Args.run_step
when 'test'
  Runner.try(command: Main::TEST, changeset: Main.new.git_changed, command_type: Command::TestCommand.new)
  Runner.try(
    command: Main::TEST_UNIFIED,
    changeset: Main.new.git_changed,
    command_type: Command::TestCommand.new('ADMIN_SETUP=unified')
  )
when 'lint'
  Runner.try(command: Main::LINT, changeset: Main.new.git_changed, command_type: Command::LintCommand.new)
when 'type_check'
  Runner.try(command: Main::TYPE_CHECK, changeset: Main.new.git_changed, command_type: Command::TypeCheckCommand.new)
else
  Main.call
end
