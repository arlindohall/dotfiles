#!/Users/millerhall/.asdf/installs/ruby/3.4.3/bin/ruby
# frozen_string_literal: true

require 'io/console'

module Command
  HOME = ENV['HOME']

  class Manager
    HOME_NAME = 'miller-home'

    def self.work? = instance.work?
    def self.instance = @instance ||= new
    def self.excalidraw_backup = work? ? WorkExcalidrawBackup : ExcalidrawBackup
    def self.tar_backup = TarBackup
    def self.git = work? ? WorkGitConfig : GitConfig
    def self.mobile = MobileGitConfig
    def self.notes_dir = "#{HOME}/var/notes"

    private

    def work?
      hostname.include? HOME_NAME
    end

    def hostname = @hostname ||= `hostname`.strip
  end

  class Helper
    def stat(git_cmd)
      warn '--- Showing stat of changes...'
      git(git_cmd)
    end

    def pause(message)
      warn "--- About to #{message}; Would you like to continue? (y/n)"
      return if $stdin.getch.match(/[yY]/)

      exit 0
    end

    def git(command)
      return if command.split.first == 'commit' && `git diff HEAD`.chomp.empty?

      try "git #{command}"
    end

    def try(command)
      warn "Running: #{command}"
      abort unless system command
    end

    def todays_date
      @todays_date ||= Time.new.strftime('%b %d, %Y')
    end
  end

  class WorkExcalidrawBackup
    DOCUMENTS_DIR = "#{HOME}/Documents/".freeze

    def self.call(helper) = new.call(helper)

    def initialize(helper)
      @helper = helper
    end

    def call
      warn "Going to documents directory #{DOCUMENTS_DIR}"
      Dir.chdir(DOCUMENTS_DIR)

      warn "Creating tar file at #{HOME}/var/ ~/var/excalidraw-backup.tar.gz"
      @helper.try "tar -cvzf \"#{HOME}/var/excalidraw-backup.tar.gz\" Excalidraw"
    end
  end

  class ExcalidrawBackup
    def self.call(**params); end
  end

  class TarBackup
    def self.call(helper) = new.call(helper)

    def initialize(helper)
      @helper = helper
    end

    def call
      warn "Going to notes directory #{ComputerType.notes_dir}"
      Dir.chdir(ComputerType.notes_dir)

      warn 'Creating tar file at $HOME/var/ ~/var/logseq-backup.tar.gz'
      @helper.try "tar -cvzf \"#{HOME}/var/logseq-backup.tar.gz\" logseq/"
    end
  end

  class WorkGitConfig
    def self.conventional_commit_tag = 'engineering-journal'
    def self.branch_name = 'tmp/rebasing-work'
    def self.push_command = 'push origin main'
  end

  class GitConfig
    def self.conventional_commit_tag = 'notes'
    def self.branch_name = 'tmp/rebasing-notes'
    def self.push_command = 'push origin mobile main'
  end

  class MobileGitConfig
    def self.conventional_commit_tag = 'mobile'
    def self.branch_name = 'mobile'
  end
end

class Backup
  class NoBackup
    def backup; end
  end

  class LocalGitBackup
    def initialize(helper)
      @helper = helper
    end

    def prefix
      @helper.stat('ls-files --other --exclude-standard')
      @helper.stat('diff HEAD')
      @helper.pause('create branch and add local changes')
      @helper.git "switch -c #{branch_name}"
    end

    def postfix
      @helper.stat('diff HEAD')
      @helper.pause('commit local changes')
    end

    def cleanup
      @helper.git "branch -d #{branch_name}"
    end

    def branch_name
      Command::Manager.git
    end

    def action
      'Note archive'
    end
  end

  class MobileGitBackup
    ICLOUD_DIRECTORY = "\"#{HOME}/Library/Mobile Documents/iCloud~com~logseq~logseq/Documents/mobile/\"".freeze

    def initialize(helper)
      @helper = helper
    end

    def prefix
      @helper.stat('diff HEAD mobile')
      @helper.pause('force-replace local changes with mobile changes')
      @helper.git "switch #{branch_name}"
      @helper.try "cp -r #{ICLOUD_DIRECTORY}* logseq/"
    end

    def postfix; end

    def cleanup
      @helper.git "switch #{branch_name}"
      @helper.git 'merge main --ff-only --log'
      @helper.try "cp -r logseq/* #{ICLOUD_DIRECTORY}"

      icloud = Pathname.new(ICLOUD_DIRECTORY).realpath
      notes = Pathname.new('logseq').realpath
      icloud.glob('**').each do |file|
        local_path = notes.join(file.relative_path_from(icloud))
        # Okay to delete because we've already copied to local, and then rebased to pick up
        # any deletions that happened on the remote, this is sort of like doing rm -rf *
        # and then re-copying, which is what I did before I added this line
        file.delete unless local_path.exist?
      end
    end

    def branch_name
      Command::Manager.mobile.branch_name
    end

    def action
      'Mobile note sync'
    end
  end

  def self.local(helper:)
    new(change: 'local', backup: LocalGitBackup.new(helper), helper: helper)
  end

  def self.mobile(helper:)
    return NoBackup.new if Command::Manager.work?

    new(change: 'mobile', backup: MobileGitBackup.new(helper), helper: helper)
  end

  def initialize(change:, backup:, helper:)
    @change = change
    @backup = backup
    @helper = helper
  end

  def backup
    warn "Pulling in changes from #{@change}..."

    @backup.prefix
    @helper.git 'add .'
    @backup.postfix

    @helper.git "commit -m \"docs(#{@backup.conventional_commit_tag}): #{@backup.action} through #{todays_date}\" --no-edit"
    @helper.git 'switch main'
    @helper.git 'pull'

    warn "Initiating merge of #{@change}..."
    warn 'If it succeeds, you will return to where you were before this command, otherwise you can stay here and fix conflicts.'

    @helper.stat("diff main #{@backup.branch_name}")
    @helper.pause("merge #{@change} changes into main")

    @helper.git "merge #{@backup.branch_name} --log -m 'merge(#{@backup.conventional_commit_tag}): Copy changes from #{@backup.branch_name} into main #{todays_date}'"

    @backup.cleanup
  end
end

class NoteBackup
  def self.call(helper:) = new(helper:).call

  def initialize(helper:)
    @helper = helper
  end

  def call
    Command::Manager.excalidraw_backup.call(@helper)
    Command::Manager.tar_backup.call(@helper)

    Backup.local(helper: @helper).backup
    Backup.mobile(helper: @helper).backup

    @helper.git 'switch main'
    warn 'Backing up to remote...'
    @helper.stat('diff origin/main main')
    @helper.pause('push changes to remote')

    @helper.git Command::Manager.git.push_command
    warn 'Backups can be found at ~/var/'
  end
end

NoteBackup.call(helper: Command::Helper.new)
