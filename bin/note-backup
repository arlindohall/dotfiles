#!/Users/millerhall/.asdf/installs/ruby/3.4.3/bin/ruby
# frozen_string_literal: true

require 'io/console'

module Command
  HOME = ENV['HOME']

  class Manager
    HOME_NAME = 'miller-home'

    def self.work? = instance.work?
    def self.instance = @instance ||= new
    def self.excalidraw_backup = work? ? WorkExcalidrawBackup : ExcalidrawBackup
    def self.tar_backup = TarBackup
    def self.git = work? ? WorkGitConfig : GitConfig
    def self.mobile = work? ? NoBackup : MobileGitConfig
    def self.notes_dir = "#{HOME}/var/notes"

    private

    def work?
      hostname.include? HOME_NAME
    end

    def hostname = @hostname ||= `hostname`.strip
  end

  module Helper
    def stat(git_cmd)
      warn '--- Showing stat of changes...'
      git(git_cmd)
    end

    def pause(message)
      warn "--- About to #{message}; Would you like to continue? (y/n)"
      return if $stdin.getch.match(/[yY]/)

      exit 0
    end

    def git(command)
      return if command.split.first == 'commit' && `git diff HEAD`.chomp.empty?

      try "git #{command}"
    end

    def try(command)
      warn "Running: #{command}"
      abort unless system command
    end

    def todays_date
      @todays_date ||= Time.new.strftime('%b %d, %Y')
    end
  end

  class WorkExcalidrawBackup
    include Command::Helper

    DOCUMENTS_DIR = "#{HOME}/Documents/".freeze

    def self.call = new.call

    def call
      warn "Going to documents directory #{DOCUMENTS_DIR}"
      Dir.chdir(DOCUMENTS_DIR)

      warn "Creating tar file at #{HOME}/var/ ~/var/excalidraw-backup.tar.gz"
      try "tar -cvzf \"#{HOME}/var/excalidraw-backup.tar.gz\" Excalidraw"
    end
  end

  class ExcalidrawBackup
    def self.call; end
  end

  class TarBackup
    include Command::Helper

    def self.call = new.call

    def call
      warn "Going to notes directory #{ComputerType.notes_dir}"
      Dir.chdir(ComputerType.notes_dir)

      warn 'Creating tar file at $HOME/var/ ~/var/logseq-backup.tar.gz'
      try "tar -cvzf \"#{HOME}/var/logseq-backup.tar.gz\" logseq/"
    end
  end

  class WorkGitConfig
    def self.conventional_commit_tag = 'engineering-journal'
    def self.branch_name = 'tmp/rebasing-work'
    def self.push_command = 'push origin main'
  end

  class GitConfig
    def self.conventional_commit_tag = 'notes'
    def self.branch_name = 'tmp/rebasing-notes'
    def self.push_command = 'push origin mobile main'
  end

  class MobileGitConfig
    def self.conventional_commit_tag = 'mobile'
    def self.branch_name = 'mobile'
  end
end

class Backup
  class NoBackup
    def backup; end
  end

  class LocalGitBackup
    def prefix
      stat('ls-files --other --exclude-standard')
      stat('diff HEAD')
      pause('create branch and add local changes')
      git "switch -c #{branch_name}"
    end

    def postfix
      stat('diff HEAD')
      pause('commit local changes')
    end

    def cleanup
      git "branch -d #{branch_name}"
    end

    def branch_name
      Command::Manager.git
    end

    def action
      'Note archive'
    end
  end

  class MobileGitBackup
    ICLOUD_DIRECTORY = "\"#{HOME}/Library/Mobile Documents/iCloud~com~logseq~logseq/Documents/mobile/\"".freeze

    def prefix
      stat('diff HEAD mobile')
      pause('force-replace local changes with mobile changes')
      git "switch #{branch_name}"
      try "cp -r #{ICLOUD_DIRECTORY}* logseq/"
    end

    def postfix; end

    def cleanup
      git "switch #{branch_name}"
      git 'merge main --ff-only --log'
      try "rm -r #{ICLOUD_DIRECTORY}*"
      try "cp -r logseq/* #{ICLOUD_DIRECTORY}"
    end

    def branch_name
      Command::Manager.mobile
    end

    def action
      'Mobile note sync'
    end
  end

  def self.for(change)
    if change == 'local'
      new(change, LocalGitBackup.new)
    elsif change == 'mobile' && Command::Manager.work?
      NoBackup.new
    else
      new(change, MobileGitBackup.new)
    end
  end

  def initialize(change, backup)
    @change = change
    @backup = backup
  end

  def backup
    warn "Pulling in changes from #{@change}..."

    @backup.prefix
    git 'add .'
    @backup.postfix

    git "commit -m \"docs(#{@backup.conventional_commit_tag}): #{@backup.action} through #{todays_date}\" --no-edit"
    git 'switch main'
    git 'pull'

    warn "Initiating merge of #{@change}..."
    warn 'If it succeeds, you will return to where you were before this command, otherwise you can stay here and fix conflicts.'

    stat("diff main #{@backup.branch_name}")
    pause("merge #{@change} changes into main")

    git "merge #{@backup.branch_name} --log -m 'merge(#{@backup.conventional_commit_tag}): Copy changes from #{@backup.branch_name} into main #{todays_date}'"

    @backup.cleanup
  end
end

class NoteBackup
  include Command::Helper

  def self.call = new.call

  def call
    Command::Manager.excalidraw_backup.call
    Command::Manager.tar_backup.call

    Backup.for('local').backup
    Backup.for('mobile').backup

    git 'switch main'
    warn 'Backing up to remote...'
    stat('diff origin/main main')
    pause('push changes to remote')

    git Command::Manager.git.push_command
    warn 'Backups can be found at ~/var/'
  end
end

NoteBackup.call
